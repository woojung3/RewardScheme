package kr.ac.mju.islab;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.protobuf.ByteString;

import it.unisa.dia.gas.jpbc.Element;
import kr.ac.mju.islab.RewardProto.RewardPacket;

/**
 * RewardQuery class is a client-side concrete implementation of 
 * 'Privacy-Preserving Reward System for Cloudnet' developed by
 * Dae Hyun Yum at August 14, 2016.
 * <p>
 * RewardQuery class does query on a server-side concrete implementation,
 * which are RewardServer objects.
 * <p>
 * If you are only interested on application,
 * you do not need to check detailed class like RewardScheme.
 * 
 * @author jwlee
 * @version 1.0.0
 * @since 2017-03-08
 */
public class RewardQuery {
	public String host;
	public int port;
	public RewardScheme rewardScheme;

	/**
	 * Class constructor specifying host ip and port.
	 * 
	 * @param host the ip of server to connect
	 * @param port the port of server to connect
	 */
	public RewardQuery(String host, int port) {
		this.host = host;
		this.port = port;
		this.rewardScheme = new RewardScheme();
	}
	
	/**
	 * Congifure engine of the query class, so that it can be act as a helper. 
	 * 
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public void configureAsHelper() throws IOException, InterruptedException {
		// Packet for RewardScheme.y / pid 101
		Element y = rewardScheme.G2.newElementFromBytes(
				new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(101)
						.build())
				.recvPacket.getE1().toByteArray()
				).getImmutable();
		// Packet for RewardScheme.g1 / pid 102
		Element g1 = rewardScheme.G1.newElementFromBytes(
				new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(102)
						.build())
				.recvPacket.getE1().toByteArray()
				).getImmutable();
		// Packet for RewardScheme.g2 / pid 103
		Element g2 = rewardScheme.G2.newElementFromBytes(
				new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(103)
						.build())
				.recvPacket.getE1().toByteArray()
				).getImmutable();

		this.rewardScheme.configureAsHelper(y, g1, g2);
	}
	
	/**
	 * Returns random serial number s, random number r, and 
	 * computed value h to Helper.
	 * Helper will use there data in recIssue Process.
	 * Especially, h will be sent to Master to generate psi.
	 * @return the serial number s, random number r, and computed h in Element[] form with corresponding order.
	 */
	public Element[] recIssueHelperPre() {
		// Play Helper's role (client) in recIssue Process.
		Element[] rtn = rewardScheme.recIssueHelperPre();
		
		return rtn;
	}
	
	/**
	 * Returns element psi which master generates in recIssue Process
	 * Helper provides h, and later generates receipt sigma with returned value psi.
	 * 
	 * @param h the element generated and provided by Helper
	 * @return the mid-computation element psi for Helper
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public Element recIssueMaster(Element h) throws IOException, InterruptedException {
		// Pass h to master
		// Packet for RewardScheme.recIssueMaster / pid 0
		Element psi = rewardScheme.G1.newElementFromBytes(
				new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(0)
						.setE1(ByteString.copyFrom(h.toBytes()))
						.build())
				.recvPacket.getE1().toByteArray()
				).getImmutable();
		return psi;
	}
	
	/**
	 * Returns the receipt sigma for Helper.
	 * sigma, along with random number s and verification key y,
	 * will be used in verification process.
	 * 
	 * @param r mid-computation value generate by Helper
	 * @param psi mid-computation value generated by Master
	 * @param y the verification key vk
	 * @return the receipt sigma for Helper
	 */
	public Element recIssueHelperPost(Element r, Element psi, Element y) {
		// Generate sigma from master's response, psi.
		Element sigma = rewardScheme.recIssueHelperPost(r, psi, rewardScheme.y).getImmutable();
		return sigma;
	}
	
	/**
	 * Returns boolean value which indicates the validness of the signature sigma.
	 * 
	 * @param sigma the receipt generated by Helper
	 * @param s the random number generated by Helper
	 * @param y the verification key vk
	 * @return validness of the signature sigma
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public boolean verify(Element sigma, Element s, Element y) throws IOException, InterruptedException {
		// Packet for RewardScheme.verify / pid 1
		boolean isValid = new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(1)
						.setE1(ByteString.copyFrom(sigma.toBytes()))
						.setE2(ByteString.copyFrom(s.toBytes()))
						.setE3(ByteString.copyFrom(rewardScheme.y.toBytes()))
						.build())
				.recvPacket.getIsValid();
		return isValid;
	}

	/**
	 * Returns aggregated sigma from provided signature sigmas.
	 * 
	 * @param sigmaList the arraylist of signature sigma
	 * @return aggregated signature sigma
	 */
	public Element aggregate(List<Element> sigmaList) {
		return rewardScheme.aggregate(sigmaList);
	}
	
	/**
	 * Returns boolean value which indicates the validness of the 
	 * aggregated signature sigma.
	 * 
	 * @param sigmaAgg the aggregated signature sigma
	 * @param sList the arraylist of random serial number s
	 * @param yList the arraylist of verification key vk, or y
	 * @return validness of the aggregated signature sigma
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public boolean aggVerify(Element sigmaAgg, List<Element> sList, List<Element> yList) throws IOException, InterruptedException {
		boolean isValid = new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(2)
						.setE1(ByteString.copyFrom(sigmaAgg.toBytes()))
						.addAllEList1(ElementListToByteStringList(sList))
						.addAllEList2(ElementListToByteStringList(yList))
						.build())
				.recvPacket.getIsValid();
		return isValid;
	}
	
	private List<ByteString> ElementListToByteStringList(List<Element> eList) {
		List<ByteString> bList= new ArrayList<ByteString>();
		for (Element e : eList) {
		  bList.add(e == null ? null : ByteString.copyFrom(e.toBytes()));
		}
		return bList;
	}
}
