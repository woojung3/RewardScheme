package kr.ac.mju.islab;

import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.List;

import org.apache.commons.codec.binary.Hex;
import org.apache.commons.io.IOUtils;

import com.google.protobuf.ByteString;

import it.unisa.dia.gas.jpbc.Element;
import kr.ac.mju.islab.RewardProto.RewardPacket;

/**
 * RewardQuery class is a client-side concrete implementation of 
 * 'Privacy-Aware Reward System'.
 * <p>
 * RewardQuery class does query on a server-side concrete implementation,
 * which are RewardServer objects.
 * <p>
 * If you are only interested on application,
 * you do not need to check detailed class like RewardScheme.
 * 
 * @author jwlee
 * @version 1.0.0
 * @since 2017-03-08
 */
public class RewardQuery {
	public String host;
	public int port;
	private RewardScheme rewardScheme;

	/**
	 * Class constructor specifying host ip and port.
	 * 
	 * @param host the ip of server to connect
	 * @param port the port of server to connect
	 */
	public RewardQuery(String host, int port) {
		this.host = host;
		this.port = port;
		this.rewardScheme = new RewardScheme();
	}
	
	/**
	 * Get y that helper currently thinks that Master holds
	 * 
	 * @return the y that helper currently thinks that Master holds
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public byte[] gety() throws IOException, InterruptedException {
		return rewardScheme.y.toBytes();
	}
	
	/**
	 * Congifure engine of the query class, so that it can be act as a helper. 
	 * 
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public void configureAsHelper() throws IOException, InterruptedException {
		// Packet for RewardScheme.y / pid 101
		Element y = rewardScheme.G2.newElementFromBytes(
				new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(101)
						.build())
				.recvPacket.getE1().toByteArray()
				).getImmutable();
		// Packet for RewardScheme.g1 / pid 102
		Element g1 = rewardScheme.G1.newElementFromBytes(
				new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(102)
						.build())
				.recvPacket.getE1().toByteArray()
				).getImmutable();
		// Packet for RewardScheme.g2 / pid 103
		Element g2 = rewardScheme.G2.newElementFromBytes(
				new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(103)
						.build())
				.recvPacket.getE1().toByteArray()
				).getImmutable();

		this.rewardScheme.configureAsHelper(y, g1, g2);
	}
	
	/**
	 * Returns random serial number s, random number r, and 
	 * computed value h to Helper.
	 * Helper will use there data in recIssue Process.
	 * Especially, h will be sent to Master to generate psi.
	 * @return the serial number s, random number r, and computed h in Element[] form with corresponding order.
	 */
	public byte[][] recIssueHelperPre() {
		// Play Helper's role (client) in recIssue Process.
		Element[] rtn = rewardScheme.recIssueHelperPre();
		
		byte[][] rtnBytes = new byte[3][];
		
		for (int i = 0; i < rtn.length; i++) {
			rtnBytes[i] = rtn[i].toBytes();
		}
		
		return rtnBytes;
	}
	
	/**
	 * Returns element psi which master generates in recIssue Process
	 * Helper provides h, and later generates receipt sigma with returned value psi.
	 * 
	 * @param hBytes the element generated and provided by Helper
	 * @return the mid-computation element psi for Helper
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public byte[] recIssueMaster(byte[] hBytes) throws IOException, InterruptedException {
		// Pass h to master
		// Packet for RewardScheme.recIssueMaster / pid 1
		Element psi = rewardScheme.G1.newElementFromBytes(
				new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(1)
						.setE1(ByteString.copyFrom(hBytes))
						.build())
				.recvPacket.getE1().toByteArray()
				).getImmutable();
		return psi.toBytes();
	}
	
	/**
	 * Returns the receipt sigma for Helper.
	 * sigma, along with random number s and verification key y,
	 * will be used in verification process.
	 * 
	 * @param rBytes mid-computation value generate by Helper
	 * @param psiBytes mid-computation value generated by Master
	 * @param yBytes the verification key vk
	 * @return the receipt sigma for Helper
	 */
	public byte[] recIssueHelperPost(byte[] rBytes, byte[] psiBytes, byte[] yBytes) {
		// Generate sigma from master's response, psi.
		Element sigma = rewardScheme.recIssueHelperPost(
				rewardScheme.Zr.newElementFromBytes(rBytes), 
				rewardScheme.G1.newElementFromBytes(psiBytes), 
				rewardScheme.y).getImmutable();
		return sigma.toBytes();
	}
	
	/**
	 * Returns boolean value which indicates the validness of the signature sigma.
	 * 
	 * @param sigmaBytes the receipt generated by Helper
	 * @param sBytes the random number generated by Helper
	 * @param yBytes the verification key vk
	 * @return validness of the signature sigma
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public boolean verify(byte[] sigmaBytes, byte[] sBytes, byte[] yBytes) throws IOException, InterruptedException {
		// Packet for RewardScheme.verify / pid 2
		boolean isValid = new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(2)
						.setE1(ByteString.copyFrom(sigmaBytes))
						.setE2(ByteString.copyFrom(sBytes))
						.setE3(ByteString.copyFrom(gety()))
						.build())
				.recvPacket.getIsValid();
		return isValid;
	}

	/**
	 * Returns aggregated sigma from provided signature sigmas.
	 * 
	 * @param sigmaBytesList the arraylist of signature sigma
	 * @return aggregated signature sigma
	 */
	public byte[] aggregate(List<byte[]> sigmaBytesList) {
		List<Element> sigmaList = new ArrayList<Element>();
		for (byte[] b : sigmaBytesList) {
			sigmaList.add(rewardScheme.G2.newElementFromBytes(b));
		}
		Element rtn = rewardScheme.aggregate(sigmaList);
		return rtn.toBytes();
	}
	
	/**
	 * Returns boolean value which indicates the validness of the 
	 * aggregated signature sigma.
	 * 
	 * @param sigmaAggBytes the aggregated signature sigma
	 * @param sBytesList the arraylist of random serial number s
	 * @param yBytesList the arraylist of verification key vk, or y
	 * @return validness of the aggregated signature sigma
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public boolean aggVerify(byte[] sigmaAggBytes, List<byte[]> sBytesList, List<byte[]> yBytesList) throws IOException, InterruptedException {
		// Packet for RewardScheme.aggVerify / pid 2
		boolean isValid = new RewardClient(host, port, RewardPacket.newBuilder()
						.setPid(3)
						.setE1(ByteString.copyFrom(sigmaAggBytes))
						.addAllEList1(BytesListToByteStringList(sBytesList))
						.addAllEList2(BytesListToByteStringList(yBytesList))
						.build())
				.recvPacket.getIsValid();
		return isValid;
	}

	/**
	 * Returns boolean value which indicates the validness of the signature sigma.
	 * 
	 * @param sigmaBytes the receipt generated by Helper
	 * @param sBytes the random number generated by Helper
	 * @param yBytes the verification key vk
	 * @param hostREST host of a RESTful server
	 * @param portREST port of a RESTful server
	 * @return validness of the signature sigma
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public boolean verifyREST(byte[] sigmaBytes, byte[] sBytes, byte[] yBytes, String hostREST, int portREST) throws IOException, InterruptedException {
		RewardPacket sendPacket = RewardPacket.newBuilder()
						.setPid(2)
						.setE1(ByteString.copyFrom(sigmaBytes))
						.setE2(ByteString.copyFrom(sBytes))
						.setE3(ByteString.copyFrom(gety()))
						.build();
		String strRest = new String(Hex.encodeHex(sendPacket.toByteArray()));
		
		URL url = new URL("http://" + hostREST + ":" + portREST + "/verify/" + strRest);
		URLConnection con = url.openConnection();
		InputStream in = con.getInputStream();
		String encoding = con.getContentEncoding();
		encoding = encoding == null ? "UTF-8" : encoding;
		String body = IOUtils.toString(in, encoding);

		return Boolean.valueOf(body);
	}
	
	// TODO
	/**
	 * Returns boolean value which indicates the validness of the 
	 * aggregated signature sigma.
	 * 
	 * @param sigmaAggBytes the aggregated signature sigma
	 * @param sBytesList the arraylist of random serial number s
	 * @param yBytesList the arraylist of verification key vk, or y
	 * @param hostREST host of a RESTful server
	 * @param portREST port of a RESTful server
	 * @return validness of the aggregated signature sigma
	 * @throws IOException Signals that an I/O exception of some sort has occurred
	 * @throws InterruptedException Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity
	 */
	public boolean aggVerifyREST(byte[] sigmaAggBytes, List<byte[]> sBytesList, List<byte[]> yBytesList, String hostREST, int portREST) throws IOException, InterruptedException {
		RewardPacket sendPacket = RewardPacket.newBuilder()
						.setPid(3)
						.setE1(ByteString.copyFrom(sigmaAggBytes))
						.addAllEList1(BytesListToByteStringList(sBytesList))
						.addAllEList2(BytesListToByteStringList(yBytesList))
						.build();
		String strRest = new String(Hex.encodeHex(sendPacket.toByteArray()));
		
		URL url = new URL("http://" + hostREST + ":" + portREST + "/aggVerify/" + strRest);
		URLConnection con = url.openConnection();
		InputStream in = con.getInputStream();
		String encoding = con.getContentEncoding();
		encoding = encoding == null ? "UTF-8" : encoding;
		String body = IOUtils.toString(in, encoding);

		return Boolean.valueOf(body);
	}
	
	private List<ByteString> BytesListToByteStringList(List<byte[]> bList) {
		List<ByteString> bsList= new ArrayList<ByteString>();
		for (byte[] b : bList) {
		  bsList.add(b == null ? null : ByteString.copyFrom(b));
		}
		return bsList;
	}
}
